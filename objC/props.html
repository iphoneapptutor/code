<article class="first last">
	<h2>Objective-C Properties</h2>
	<p>
		The principle of encapsulation requires that in order to use an object, you should not need to know how the object works. If a class were well designed, then in order to use it, you only need to know of a list of methods provided by the object.

		Member variables, although an essential component of an object, are part of the object’s internal details and thus are not accessible to users directly. The interface of the Planet class that has been used in the previous sections of this appendix is presented once again:
		<br />
		<br />

		#import
		<Foundation/Foundation.h>
			<br />
			<br />

			@interface Planet : NSObject
			<br />
			{
			<br />
			float surfaceTemperature;
			<br />
			}
			<br />
			<br />

			- (void)spinOnAxis;
			<br />
			- (float)distanceFromSun;
			<br />
			- (void)rotatePlanetByAngle:(float)angle;
			<br />
			<br />

			@end
			<br />
			<br />

			In order to give other classes (including subclasses) the ability to read/change the value of the instance variable surfaceTemperature, you will need to add a pair of accessor methods to the class. A method that is used to read the value of an instance variable is known as a getter, and a method used to change an instance variable is called a setter. It turns out that accessor methods are created quite frequently, and in order to simplify the process of creating these accessors, Objective-C provides the concept of synthesized properties.
			<br />

			Essentially, you declare a property in your class to expose a instance variable to your users, and the compiler generates the required getter/setter method for you.
			<br />

			Thus you can expose the surfaceTemperature variable to your users by adding this statement to your class declaration, between the closing } and the @end statement:
			<br />

			@property float surfaceTemperature;
			<br />

			You can think of adding the above @property declaration statement to be equivalent to adding two methods:
			<br />
			<br />

			- (float)surfaceTemperature;
			<br />
			- (void)setSurfaceTemperature:(float)newValue;
			<br />
			<br />

			The updated Planet.h file, with a property called surfaceTemperature will look like this:
			<br />
			<br />

			@interface Planet : NSObject
			<br />
			{
			<br />
			float surfaceTemperature;
			<br />
			}
			<br />
			<br />

			@property float surfaceTemperature;
			<br />
			- (void)spinOnAxis;
			<br />
			- (float)distanceFromSun;
			<br />
			- (void)rotatePlanetByAngle:(float)angle;
			<br />
			<br />

			@end
			<br />
			<br />

			You also need to add an @synthesize statement in the .m file for each corresponding property you have added to the .h file. The @synthesize statement is added at the top of the implementation (.m) file, immediately after the @implementation line as shown here:
			<br />
			<br />

			@implementation Planet
			<br />
			<br />

			@synthesize surfaceTemperature;
			<br />
			<br />

			// other method declarations follow …
			<br />
			<br />

			@end
			<br />
			<br />

			The net effect of a pair of @property and @synthesize statements is to create both a getter and a setter method for the member variable in question. The Objective-C language also allows you to use a few modifiers with @property statements. When used, these modifiers create slightly different setter/getter methods.
			<br />

			The most common @property modifiers are nonatomic and readonly. Using the nonatomic modifier results in code that is slightly faster. A readonly property is one that can only be read, thus only a getter method is created for one of these. Objective-C properties are not read-only by default.
			<br />

			Applying these modifiers to a property is a simple matter of including the appropriate keywords in the @property statement:

			@property (readonly) float surfaceTemperature;
			<br />
			<br />
			It is common practice, when exposing an instance variable using synthesized properties, to not declare the instance variable in the .h file at all. This is because when the Objective-C compiler comes across an @property declaration without a matching instance variable declaration, it will create an instance variable automatically. Thus, the final version of the Planet.h file would resemble:
			<br />
			<br />

			@interface Planet : NSObject
			<br />
			@property float surfaceTemperature;
			<br />
			- (void)spinOnAxis;
			<br />
			- (float)distanceFromSun;
			<br />
			- (void)rotatePlanetByAngle:(float)angle;
			<br />
			<br />

			@end
			<br />
			<br />

			Last but not least, it is worth mentioning that you could override the default getter/setter method generated by the compiler with one of your own. Thus, if you wanted to use the standard compiler-generated setter method, but override the getter method, you will need to add an implementation for the setSurfaceTemperature: method in the .m file:
			<br />
			<br />

			- (void)setSurfaceTemperature:(float)newValue
			<br />
			{
			<br />
			// do something with newValue
			<br />
			}
			<br />
			<br />
			This concludes the introduction to Objective-C. For more information you are encouraged to read “The Objective-C Programming Language Guide” available at: <a href="http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html.">http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html.</a>
	</p>
</article>